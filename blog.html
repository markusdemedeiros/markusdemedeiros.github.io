<!DOCTYPE html>
<html>

<head>
	<title>Markus's Desk</title>
	<link rel="stylesheet" type="text/css" href="stylesheet.css">
	<link href="packages/prism/prism.css" rel="stylesheet" />
</head>


<body>
	<script src="packages/prism/prism.js"></script>
	<header>
		<div class="header__content-image">
			<a href="index.html">
				<img src="img/peruPic.png" alt="Photo of me" width=300em>
			</a>
		</div>
		<div class="header__content-text">
			<h1> Markus de Medeiros </h1>
			<aside> Student in mathematics and CS at UBC </aside>
			<aside> </aside>
			<hr>
			<a href="https://github.com/markusdemedeiros">[ github ]</a>
			<a href="mailto:markusdemedeiros@outlook.com?">[ email ]</a>
			<a href="https://www.markusde.ca">[ cv ]</a>
			<a href="https://www.markusde.ca">[ arxiv ]</a>
			<a href="blog.html">[ blog ]</a>
			<p align="right"> <i id="title-text"></i></p>
		</div>
		<script type="text/javascript" charset="utf-8">
			var string_list = [
				"powered by vim and coffee!",
				"trust the natural catamorphism!",
				"monads: programmable semicolons!",
				"real numbers don't exist!",
			];
			document.getElementById("title-text").innerText
				= (string_list[Math.ceil((Math.random() * string_list.length - 1))]);

		</script>
		</div>
	</header>
	<section>
		<center>
    <h1 class="blog_title">A Practical Introduction to Monads</h1>
    <p><i>September 25 2021</i></p>
</center>

<h2> <strong class="section_heading">Section 0.</strong> Introduction </h2>
<hr>
<p> Hi. My name is Markus. I am a functional programmer. Today we are going to
    learn about monads. üëè </p>

<p> I'm going to try and keep it terse and practical, so let me know at the
    links above or with a issue on github if you think there's something that
    warrants elaboration. I'll also do my best to cite the pieces which go into
    this, but it's been a couple years of depressing goole searches so if you think
    I stole your idea I probably did. <i>Please</i> let me know and I will attribute
    you ASAP. For the reader, you should also treat this page as a database of
    useful monad tutorials. All the links here are very pointed and very good. </p>


<pre data-src="example.hs"> </pre>


<p> What is a programming language? To functional programmers like us, a
    programming language consists of three big parts
<ul>
    <li><b>Types</b>, which
        include function types</li>
    <li><b>Data</b>, to populate those types, and</li>
    <li>a <b>Composition Rule</b> to combine functions and data in some useful way.
    </li>
</ul>

This characterization of a programming language isn't made up out of whole
cloth, if you ask a category theorist they will say the same thing in two-dollar
words like *morphism* (monads are burritos in the category of endofunctors,
after all). </p>

<h2>The monad design pattern</h2>

<p> Monads are a design pattern that solve the problem of wanting a language
    like Haskell (and which can interop with Haskell code) but with a little effect
    on the side. Some examples of these problems include
<ul>
    <li>Haskell, but we
        can keep track of one state alongside our computation (State monad) </li>
    <li>Haskell, but we keep track of if an error has been thrown and short circuit
        if so (Maybe monad)</li>
    <li>Haskell, but with multivalued functions modelled by
        allowing many inputs and outputs for each function (List monad) </li>
    <li>Haskell, but on the side of our computations we're parsing text (Parsec
        monad)</li>
    <li>Haskell, but we build an abstract syntax tree on the side
        without nasty recursion badness (Free monad)</li>
    <li>Purescript, but our
        computations can modify the structure of a webpage (HalogenM monad)</li>
</ul>
These are the kinds of problems monads solve: we want a copy of Haskell that
also has some extra effects. Notice the lack of <i>imperitave style
    programming</i> or <i>impurity</i>. Monads can do that too, but we'll get to
that later. </p>


<h3>Building a new language</h3>

<p> The new little language we build inside Haskell will be directly related to
    Haskell. The types will be related to Haskell types, the data will be related to
    Haskell data, and the function composition will behave well with base Haskell
    composition. Along the way we will make precise what exactly this means, but a
    good overview of the process of building a little language like this is
<ol>
    <li>Implement a Functor to build out new types</li>
    <li>Implement Applicative to
        get data and a copy of base function composition</li>
    <li>Implent the bind
        function >>= to handle composing effects</li>
</ol>
</p>

<h3>1. Types</h3>

<p> The types in out new lanuages will just be wrapped up versions of base
    Haskell types, and an easy way to do that is with a functor M. If Int is a type
    in Haskell (spoiler: it is) then M Int will be a type in our language. </p>

<p> The fmap function of a functor gives a bridge between out langauge and base
    Haskell, so that if we have a base Haskell function we can apply it to data
    inside our new language. </p>

<h3>2. Data</h3>

<p>Now that we have types, we want to populate them. To do this we will
    construct a pathway from base Haskell into our new langauge with the pure :: a
    -> M a function. </p>

<p> So great, now if I have 5 :: Int in base Haskell I can get pure 5 :: M Int
    in our new langauge. What about functions? If you squint your eyes it turns out
    we've already done this, since functions and data are the same thing here we can
    just pure a function f :: Char -> Bool to get it's equivalent in our new
    language pure f :: M (Char -> Bool)! </p>

<p> However, these functions don't really act like functions yet because we
    can't compose them. If I have a M Int and a M (Int -> String), we want to be
    able to link them up to get a M String. This is exactly what the <*> operator
        does! Let's implement it next, and make sure it follows the laws. </p>

<p> And just like that, three functions later and we have a copy of base Haskell
    composition in our new little language. If we can do show False in Haskell, we
    can do (pure show) <*> (pure False) in out langauge and get a sensible reseult.
</p>

<p> <i>Note that, while it seems obvious, this is very important. For the Maybe
        monad, the one with short circuiting errors, we define pure x = just x which
        represents a non-error value. However, it is perfectly type satisfactory and
        rule following to define pure x = Nothing, which would result in a different
        Maybe monad representing computations which immediately give up without every
        trying. The point is, people who tell you to <i>just follow the types, man</i>
        are oblivious to the fact that we are writing definitions, and you should always
        keep in mind the purpose of what the function your implementing will ultimately
        represent in your final monad and how it's semantics should work. Frankly, this
        (infuriating) trope is the reason I made this tutorial.</i> </p>


<h3>3. Composing effects</h3>

<p>If you've been following along at home, you'll know that right now the extra
    stuff we're adding to our new little language is pretty boring. For example, if
    you're implemting the Maybe monad you'll have pure = just and <*> = ... This is
        truly phenomenal boilerplate, which I'm sure will delight the ex-java readers,
        but you should note that as it stands there is no way for a computation to
        actually fail and short circuit yet! </p>

<p>Suppose we are in the middle of a computation in our new little Maybe
    langauge and we have a x = Just 5 :: Maybe Int. Suppose also we have the
    function checkFive :: Int -> Maybe Int which is id except for 5 which is
    Nothing. Can we apply checkFive to our result so far to make it fail?</p>

<p>If we use the tools we have, we could try x <*> (pure checkFive), but if you
        run this you'll get a result of type Maybe (Maybe Int) with value Just
        (Nothing). It sort of ran, but we're trying to model short circuiting here and
        right now it isn't doing that. In essence, we need a way to combine these extra
        effects together, and this is exactly what the bind function >>= m a -> (a -> m
        b) -> m b does! Running again with x >>= checkFive we get the expected short
        circuiting behavior with a value of Nothing :: Maybe Int. </p>

<p>Monads are a way to combine effects. Congrats, our little language is
    complete! This concludes the monad tutorial! Buy yourself a celebratory burrito!
    (Note: If you're all excited and ready to implement your own monad, you must
    read Appendix A first. It's critically important for the details of this
    process) </p>

<h2>What else can Monads do?</h2>

<h3>Impurity</h3>

<h3>Imperitave Style</h3>
<p>There are lots of cool monads out there, with many
    cool effects. In fact, the effects themselves are sometimes so cool we don't
    really care about the computed value anymore. The >> operator is a version of
    the bind operator which throws away the result of the computation, and
    essentially allows us to just do stuff to the effects. </p>

<p> Say I'm in the Writer monad (Haskell, but we keep a log of type String on
    the side of our computaitions), and I have functions logHello, logUsername,
    logLoginTime which all just spit out values into the log and return some unused
    junk value of unit type (). If I just want to do them in sequence, I can chain
    them like this

    logHello >> logUsername >> logLoginTime

    This looks a lot like C pseudocode

    logHello(); logUsername(); logLoginTime();

    and do notation allows us to write this composition, which looks a lot like a
    sequence of commands, in a differnt style: do ...

    Neat! The characterization of monads as programmable semicolons is good, but
    it's incomplete. While able to use >> as a semicolon is a natural way to program
    in a lot of contexts, we know that bind >>= is really the full story. Just
    another saying which inspired this post. </p>


<h3>Monad Transformers</h3> Monad Transformers allow us to stack effects on top
of each other in a principled way. ...

<h3>Free Monads</h3>

<h3>Conclusion</h3>


<h3>Appendix: Laws</h3>
<p><b>This section is a must read before you try
        implementing your own monad</b></p>
	</section>

</body>

</html>